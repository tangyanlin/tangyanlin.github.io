---
layout: post
title: "F1 中文译文"
description: ""
category: 技术
tags: [技术, 翻译]
---
{% include JB/setup %}

以前读过F1的相关论文，但是很多地方都没有读懂，想再次读的时候发现好像又是重新开始一遍的样子，当年是牺牲了十一的时间看完了所有相关的论文，想来还是记下一些会比较好。文章会主要以翻译[F1](http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41344.pdf)为主，也会加上其它相关文章的注解。估计会翻译很久很久吧，哈哈，也会关注[tidb](https://github.com/pingcap/tidb)F1的Go语言实现开发。

## F1: 扩展的分布式SQL数据库

* 摘要

F1是google用来支持AdWords业务而建立的一个分布式关系型数据库系统。F1一种混合型的数据库，将像bigtable那种NoSQL系统的可用性、可扩展性和传统的SQL数据库的一致性、易用性相结合。F1建立在Spanner之上，Spanner提供了跨数据中心的同步副本和强一致性。同步副本会导致更高的提交延时，我们可以通过结构化数据类型的分层Schema模型和灵活的应用层设计来减少延时。F1还包括了一个完整的分布式SQL查询引擎和自动化检测和发布。

* 介绍

F1是Google为了AdWords系统而建立的一种新的存储系统，它是一种容错的，完全分布式的OLTP和OLAP数据库。F1用来替代那些不能够满足可扩展性和可靠性需求的分片MySQL实现。
F1设计的主要目标是：
  * 可扩展性：系统必须可以通过增加资源简单透明地做可扩展。基于MySQL的分片数据库不容易扩展，甚至比较难重新重新负载均衡。我们的用户需要复杂的查询和join，导致对数据的分片不能过细，数据的重新分片也变得很有挑战性。

  * 可用性：系统不应该因为任何原因而宕机，数据中心中断、定期维护、schema变化等。Google核心业务系统存储的数据，任何的宕机都会造成可观的收入影响。

  * 一致性：系统必须提供ACID事务机制，而且应用必须总是呈现一致和正确的数据。在设计应用中来处理并发带来的异常是易错的、耗时的，而且没有足够回报的。

  * 易用性：系统必须提供完善的SQL查询支持和其它SQL数据库提供的功能。像索引和adhoc查询并不是必须的，但对于我们的业务是必须的。

最近的一些刊物都指出以上目标是互斥的。这篇文章一个重要的贡献就是展示了F1的设计是如何满足所有的这些目标，我们在哪些地方做了trade-off和牺牲。F1这个名字来自于遗传学，Filia 1 hybrid是由不同亲本杂交的第一代后代。F1数据库确实是一个混合物，结合了传统关系型数据库和Bigtable这种可扩展NoSQL系统的优点。
F1是建立在Spanner基础之上，Spanner提供了很好地可扩展数据存储、同步副本、强一致性和强排序性。F1继承了这些特点，并且增加了一些特点：

 * 分布式SQL查询，包括从外部数据源join数据
 * 事务一致性二层索引
 * 异步schema变化，包括数据库重组
 * 优化的事务
 * 自动变化历史记录和发布

我们的设计使F1对于一般的读写有更高的延时。我们开发了技术来隐藏增加的延时，我们发现面向用户的事务和MySQL系统有一样的性能：

 * F1 schema使得数据聚类更明确，使用分级的关系和结构化数据类型的列来使用表格。这种聚类提高了数据的本地性，减少了RPC需要从远程读取数据的次数和消耗
 * F1用户大量使用批量、并行和异步读。我们使用了一个新的ORM库来使这些概念更加清晰。这使得对于一般应用层操作需要的RPC次数有了上限，使得这些操作更容易被扩展

F1系统早在2012年就被用于管理所有AdWords广告竞选数据。AdWords是一个庞大而多样的生态系统，包括了百级的应用和千级的用户，所有都共享这些数据库。数据库超过了100TB，QPS每秒100000，每天运行的SQL查询扫描10000000000000行数据。在系统意外中断的性狂下可用性仍高达5个9，在我们web应用中可观测到的延时和MySQL系统相比并没有增加。
文中所说的Adwords数据库是使用F1的第一个用户，Google的其它几个团队现在也在计划开始部署F1。

* 基本架构

![framework](../image/f1-framework.png)

  * Spanner
* 数据模型
  * 分级Schema
  * Protocol Buffer
  * 索引
* Sechema变化
  * 灵活的锁粒度 
* 事务
* 改变历史
* 客户端设计
  * 简化的ORM
  * NoSQL接口
  * SQL接口
* 查询处理过程
  * 集中和分布式查询
  * 分布式查询样例
  * 远程数据
  * 分布式执行概要
  * 分级表join
  * 分区的消费者
  * Protocol Buffer查询
* 部署
* 延时和吞吐量
* 相关工作
* 总结
